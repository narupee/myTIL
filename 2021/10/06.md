

2021년 10월 06일
---

---

오늘 할일
----

1. 4강 체크리스트 완료 [[Github]](https://github.com/narupee/WebDevCurriculum/blob/master/Quest04/Check/Check_list.md)
2. 5강 체크리스트 완료 [[Github]](https://github.com/narupee/WebDevCurriculum/blob/master/Quest05/Check/Check_list.md)
3. 객체합성 공부

---

### 객체합성 세가지 다른 형태

- "클래스 상속보다는 객체 합성을 우선해라"라는 조언은 
- 우리가 객체를 바라보는 방식을 거대한 기본 클래스로부터 상속받는 것이 아닌 
- 작고 느슨하게 결합 된 요소들의 합성으로 생각하라는 뜻
- 
- GoF는 단단히 결합 된 객체를 "모놀리틱[1] 시스템"
  - [1] : monolithic 단일체의, 한 덩어리로 뭉친, 단일 결정으로된
    - 어떤 클래스를 변경하거나 제거하려면 다른 수많은 클래스를 이해하고 변경해야 한다.
    - 결국 이러한 시스템은 이해하고, 이식하고, 유지하기 힘든 조밀한 덩어리가 된다.
    

- `"Design Patterns"`에서 Gang of Four는 <br>
 "객체 합성은 여러 디자인 패턴에 다양하게 적용될 것 입니다" 라고 말한다.
- 집합 및 위임 을 포함한 다양한 유형의 구성 관계를 설명함
  
---

- <b>집합Aggregation </b>
  - 객체가 열거 가능한 하위 객체 모음으로 구성되는 경우
  - "다른 객체들을 포함 하는 객체" 이다
  - 각 하위 객체는 자신의 레퍼런스를 유지하므로 얼마든지 집합체에서 분리, 해체될 수 있다
  

- <b>접합Concatenation</b>
  - 기존 객체에 새 속성을 추가하여 객체를 형성하는 경우
  - 속성을 한 번에 하나씩 연결 or 기존 개체를 통채로 복사 할 수 있음
  - 예) `jQuery` 플러그인은 프로토타입으로 연결된 `jQuery.fn`에 새 메서드를 연결해 만들어진다
    

- <b>위임Delegation</b>
  - '객체를 다른 객체로 전달'하거나 '특정 기능을 위임' 하는 경우
  - 예) Ivan Sutherland의 Sketchpad (1962)에는 <br>
     공유 속성을 "마스터"에게 위임하는 인스턴스가 있다
  - Photoshop에 포함된 "스마트 오브젝트"는 외부 리소스에게 동작을 위임하는 `로컬 프록시`가 있다
  - JavaScript의 프로토타입은 위임으로 작동함
  - Array 인스턴스로 배열 메소드를 호출하면 `Array.prototype`에게 전달되고 <br>
    Object 메소드들은 `Object.prototype`에게 전달된다.
    
---

- 이러한 다른 형태의 구성은 서로 배타적이지 않다.
- 접합으로 위임을 구현 할 수 있음
- JavaScript에서 클래스 상속은 위임으로 구현
- 소프트웨어 시스템은 객체를 합성할 때 하나 이상의 방법을 사용한다.
  
---

- <b>집합 Aggregation (어그리게이션)</b>
  - 집합은 객체가 열거 가능한 하위 객체 모음으로 구성되는 경우
  - `다른 객체들을 포함 하는 객체` 이다
  - 각 `하위 객체는 자신의 레퍼런스를 유지`하므로 얼마든지 `집합체에서 분리, 해체`될 수 있다
  - 다양한 구조로 표현 될 수 있음
  

- 예제들
  - Array
  - Map
  - Set
  - Graph
  - Tree
  - DOM node (DOM 노드는 자식 노드를 포함 )
  - UI component (컴포넌트는 하위 컴포넌트들을 포함 )
  

- 언제 사용?
  - 스택, 큐, 트리, 그래프, 상태 머신 또는 컴포지트 패턴에서처럼 <br>
    공통 작업을 공유해야하는 객체 모음이있는 경우 <br>
    (수많은 아이템들이 동일한 인터페이스를 공유하려는 경우)
  

- 참고사항
  - 집합을 사용하면 각 멤버에게 함수를 적용하고( e.g. array.map(fn) ) <br>
    단일 값인 것처럼 벡터를 변환하는 등 보편적인 추상화를 적용할 수 있다.
  - but, 수십, 수백만개의 하위 객체를 다뤄야할 경우 <br>
    스트림으로 처리하는 것이 더 효율적일 수 있음
  

- <b>접합, 연결 Concatenation</b>
  - 기존 객체에 새 속성을 추가하여 객체를 형성하는 것
  

- 언제 사용?
  - JSON 객체 합치기, 여러 소스에서 애플리케이션 상태를 가져오기, <br>
     불변 상태를 업데이트 하기(이전 상태를 새 데이터와 병합)등 
  - 런타임에 점진적으로 데이터 구조를 조립하는 것이 필요하다면 언제든 가능
  

- 참고사항
  - 기존 객체를 변이시킬 때 주의
  - 변경 가능한 공유 상태는 많은 버그를 일으킬 수 있다
  - 클래스 계층 구조를 모방하는 것이 가능 ->  `is-a 관계`를 만들 수 있음
  - “기본” 인스턴스에서 속성들을 상속하고 다중상속을 하는 대신 <br>
    작고 독립적인 객체들을 "합성"한다는 아이디어로 접근해야 한다.
  - 구성요소들간의 암시적인 종속성에 주의
  - 속성 이름 충돌은 연결 순서로 해결 (마지막 값이 적용됨)
    - 기본값을 지정하거나 오버라이딩 할 때 유용
    - 순서가 명확하지 않은 경우 문제가 될 수 있음
  

- <b>위임 Delegation</b>
  - 객체를 다른 객체로 전달하거나 특정 기능을 위임 하는 경우
  

- 예제들
  - `JavaScript`은 `기본적으로 위임을 사용`하여 메소드 호출을 `프로토타입 체인으로 전달`함
    - e.g. `[].map()` 은 `Array.prototype.map()`으로
    - `obj.hasOwnProperty()` 는 `Object.prototype.hasOwnProperty()` 으로 호출이 위임됨
  - jQuery 플러그인은 위임을 사용해 모든 인스턴스에서 내장 및 플러그인 메소드를 공유
  - `Sketchpad`의 "마스터"는 `동적 위임자`
    - 마스터의 변경사항은 `모든 객체 인스턴스에 즉시 반영`
  - `Photoshop`는 "스마트 객체"라는 위임자를 사용해 별도의 파일에 정의 된 <br>
    이미지와 리소스를 나타낸다
    - 스마트 오브젝트가 참조하는 오브젝트에 대한 변경 사항은
    - 스마트 오브젝트의 모든 인스턴스에 반영됨
  

- 언제 사용?
  - 메모리 절약 : 객체의 인스턴스가 매우 많을 경우
    - 각 인스턴스마다 메모리를 더 많이 할당해하는 대신
    - 인스턴스간에 동일한 속성이나 메소드를 공유하는 것이 유용
      <br>
      <br>
  - 많은 인스턴스를 동적으로 업데이트
    - 많은 객체 인스턴스가 동일한 상태를 공유
    - 동적으로 업데이트해야 하는 경우
    - 변경사항을 즉석에서 모든 인스턴스에 반영시킬 수 있다
    - 예) Sketchpad의 "마스터"또는 Photoshop의 “스마트 객체”
  

- 참고사항
  - 위임은 일반적으로 `JavaScript`에서 클래스 상속을 모방하는 데 사용 <br>
    (실제로 extends 키워드에 묶여 있음) 실제로는 거의 필요하지 않다.
  - 위임을 사용해 클래스 상속의 `동작 및 제한 사항`을 정확하게 모방 할 수 있다
  - `JavaScript`의 클래스 상속은 `프로토타입 위임 체인으로 구축`되어 있다
  - 위임된 속성은 `Object.keys(instanceObj)`와 같은 일반적인 메커니즘을 사용하여 열거 할 수 없다
    - 위임은 속성 조회 속도를 희생해 메모리를 절약
    - JS 엔진은 일부 동적 위임자(생성 된 후에 변경되는 위임자)에 대한 최적화를 수행하지 못함
    - but, 가장 느린 경우에도 속성 조회 성능은 수백만 ops /초로 측정됨
    - 이벤트 스트림 처리용 혹은 그래픽 프로그래밍용 범용 유틸리티 라이브러리 <br>
      (e.g. RxJS 또는 three.js)가 아닌 이상 병목 현상이 발생하긴 쉽지 않다
  - `인스턴스의 상태`와 `위임된 상태`를 구별해야한다.
  - 동적으로 위임된 공유 상태는 안전하지 않음
    - 변경사항은 모든 인스턴스간에 공유됨
    - 일반적으로 (항상 그런 것은 아님) 버그를 발생시키는 원인
  - ES6에서 클래스의 프로토타입은 재할당될 수 없다
    - 바벨로 컴파일했을 때 작동하는 것처럼 보일지라도 실제 ES6 환경에서는 오류가 발생한다.
  - 결론은 출처 확인하기 : [링크](https://tpgns.github.io/2018/04/23/the-hidden-treasures-of-object-composition/)
  

- 추가
  - 세 가지 종류의 객체 합성만 있는 것이 아니다
    - 객체가 다른 객체에게 매개 변수로 전달되는(의존성 삽입) 등의 관계를 통해 <br>
      객체간에 느슨하고 동적인 관계를 형성 할 수도 있다.
  - 모든 소프트웨어 개발은 합성이다
    - 객체 합성의 일부 형태는 느슨하게 연결된 관계를 형성
    - 다른 형태는 매우 단단한 결합을 형성
  - 프로그램 요구사항이 변경되었을 때
    - 코드 구현을 조금만 변경하기 위해선 다양한 합성 형태를 찾기
    - 의도를 명확하고 간결하게 표현하고 기억하기
    - 클래스 상속이 필요하다고 생각이 들 때 사실 더 좋은 방법 찾아보기
    
---

